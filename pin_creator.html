<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Pin Creator & Editor</title>
  <style>
    body {
      background: #111;
      color: white;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 1rem;
      margin: 0;
    }

    #instructions {
      max-width: 800px;
      text-align: center;
      font-size: 14px;
      margin-bottom: 1rem;
      color: #ccc;
    }

    #map-frame {
      border: 2px solid #555;
      border-radius: 12px;
      overflow: hidden;
      width: 90vmin;
      aspect-ratio: 12660 / 10516; /* Lock the true aspect ratio */
      background: #222;
      position: relative;
      box-shadow: 0 0 20px black;
    }

    #map-container {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      transform-origin: 0 0;
      cursor: grab;
    }

    #map-image {
      width: 100%;
      height: 100%;
      object-fit: contain;
      pointer-events: none;
      user-select: none;
    }

    .pin {
      position: absolute;
      width: 5px;
      height: 5px;
      background: red;
      border-radius: 10%;
      border: 1px solid white;
      cursor: pointer;
      transition: background 0.1s;
    }

    .pin.selected {
      background: yellow;
    }

    form {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 1rem 0;
    }

    input, button {
      margin: 0.3rem;
      padding: 0.5rem;
      width: 300px;
    }

    #buttons {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 0.5rem;
    }

    button {
      width: 140px;
    }
  </style>
</head>
<body>
  <h1>Pin Creator & Editor</h1>
  <div id="instructions">
    <p><strong>Instructions:</strong></p>
    <ul>
      <li>🔍 Scroll to zoom. Drag to pan.</li>
      <li>📌 Click to add new pins, or click to move selected pin.</li>
      <li>🖱️ Click pins to edit/delete.</li>
      <li>💾 Use buttons to load/save <code>pins.json</code>.</li>
    </ul>
  </div>

  <div id="map-frame">
    <div id="map-container">
      <img id="map-image" alt="Map" />
    </div>
  </div>

  <form id="form">
    <input type="text" id="title" placeholder="Video Title" required>
    <input type="text" id="video" placeholder="Video URL" required>
<select id="tag-select">
<option value="Culture">Culture</option>
<option value="Health">Health</option>
<option value="History">History</option>
<option value="Nature">Nature</option>
</select>
  </form>

  <div id="buttons">
    <button type="button" id="save-btn">💾 Save Pin</button>
    <button type="button" id="delete-btn">🗑️ Delete Pin</button>
    <button type="button" id="load">📂 Load pins.json</button>
    <button type="button" id="download">⬇️ Download JSON</button>
  </div>

  <script>
  const frame = document.getElementById('map-frame');
  const container = document.getElementById('map-container');
  const image = document.getElementById('map-image');
  image.src = `ipamap.png?t=${Date.now()}`;

  const titleInput = document.getElementById('title');
  const videoInput = document.getElementById('video');
const tagSelect = document.getElementById("tag-select");

  let pins = [];
  let selectedPinIndex = null;
  let scale = 1;
  let translate = { x: 0, y: 0 };
  let start = { x: 0, y: 0 };
  let isDragging = false;
  let justDragged = false;

  image.onload = () => {
    frame.style.aspectRatio = `${image.naturalWidth}/${image.naturalHeight}`;
  };

  function getMinScale() {
    return 1;
  }

  function updateTransform() {
    container.style.transform = `translate(${translate.x}px, ${translate.y}px) scale(${scale})`;

    const frameRect = frame.getBoundingClientRect();

    // Adjust pin block scale + transform origin
    [...document.querySelectorAll('.pin-block')].forEach(pin => {
      // Keep pins same visual size
      pin.style.transform = `translate(-50%, -50%) scale(${1 / scale})`;

      // Optional: force layout recalculation if previews jitter
      pin.style.transformOrigin = "center";
    });
  }


  function clampTranslate() {
    const frameRect = frame.getBoundingClientRect();
    const containerWidth = frameRect.width * scale;
    const containerHeight = frameRect.height * scale;
    const maxX = 0;
    const maxY = 0;
    const minX = frameRect.width - containerWidth;
    const minY = frameRect.height - containerHeight;

    translate.x = Math.min(maxX, Math.max(minX, translate.x));
    translate.y = Math.min(maxY, Math.max(minY, translate.y));
  }

  function drawPins() {
    [...container.querySelectorAll('.pin')].forEach(p => p.remove());
    pins.forEach((pin, i) => {
      const el = document.createElement('div');
      el.className = 'pin';
      if (i === selectedPinIndex) el.classList.add('selected');

      el.style.left = `${pin.x}%`;
      el.style.top = `${pin.y}%`;
      el.style.transform = `translate(-50%, -100%)`;
      el.title = pin.title;

      el.addEventListener('click', (e) => {
        e.stopPropagation();
        selectPin(i);
      });

      container.appendChild(el);
    });
  }

  function selectPin(index) {
    selectedPinIndex = index;
    const pin = pins[index];
    titleInput.value = pin.title;
    videoInput.value = pin.video;
    tagSelect.value = pin.tag || "";
    drawPins();
  }

  function getMapClickCoords(e) {
    const rect = frame.getBoundingClientRect();
    const localX = (e.clientX - rect.left - translate.x) / scale;
    const localY = (e.clientY - rect.top - translate.y) / scale;
    const percentX = (localX / rect.width) * 100;
    const percentY = (localY / rect.height) * 100;
    return {
      x: Math.max(0, Math.min(100, percentX)),
      y: Math.max(0, Math.min(100, percentY))
    };
  }

  container.addEventListener('click', (e) => {
    if (justDragged) {
      justDragged = false;
      return;
    }
    const coords = getMapClickCoords(e);
    if (selectedPinIndex !== null) {
      pins[selectedPinIndex].x = coords.x;
      pins[selectedPinIndex].y = coords.y;
      selectedPinIndex = null;
    } else {
      pins.push({
        title: titleInput.value.trim(),
        tag: tagSelect.value,
        video: videoInput.value.trim(),
        x: coords.x,
        y: coords.y
      });
      titleInput.value = '';
      videoInput.value = '';
      tagSelect.value = '';
    }
    drawPins();
  });

  document.getElementById('save-btn').addEventListener('click', () => {
    if (selectedPinIndex !== null) {
      pins[selectedPinIndex].title = titleInput.value.trim();
      pins[selectedPinIndex].video = videoInput.value.trim();
      pins[selectedPinIndex].tag = tagSelect.value;
      selectedPinIndex = null;
      drawPins();
      titleInput.value = '';
      videoInput.value = '';
      tagSelect.value = '';
    }
  });

  document.getElementById('delete-btn').addEventListener('click', () => {
    if (selectedPinIndex !== null) {
      pins.splice(selectedPinIndex, 1);
      selectedPinIndex = null;
      drawPins();
      titleInput.value = '';
      videoInput.value = '';
      tagSelect.value = '';
    }
  });

  document.getElementById('load').addEventListener('click', async () => {
    try {
      const response = await fetch(`pins.json?t=${Date.now()}`);
      pins = await response.json();
      selectedPinIndex = null;
      drawPins();
      alert('✅ Pins loaded.');
    } catch {
      alert('❌ Failed to load pins.json');
    }
  });

  document.getElementById('download').addEventListener('click', () => {
    const blob = new Blob([JSON.stringify(pins, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'pins.json';
    a.click();
    URL.revokeObjectURL(url);
  });

  frame.addEventListener('wheel', (e) => {
    e.preventDefault();
    const zoomFactor = 0.1;
    const oldScale = scale;
    const proposedScale = e.deltaY < 0 ? scale + zoomFactor : scale - zoomFactor;
    scale = Math.max(getMinScale(), Math.min(proposedScale, 4));
    const rect = frame.getBoundingClientRect();
    const cx = e.clientX - rect.left;
    const cy = e.clientY - rect.top;
    translate.x -= cx / oldScale - cx / scale;
    translate.y -= cy / oldScale - cy / scale;
    clampTranslate();
    updateTransform();
  });

  container.addEventListener('mousedown', (e) => {
    isDragging = true;
    justDragged = false;
    container.style.cursor = "grabbing";
    start = { x: e.clientX - translate.x, y: e.clientY - translate.y };
  });

  window.addEventListener('mousemove', (e) => {
    if (!isDragging) return;
    translate.x = e.clientX - start.x;
    translate.y = e.clientY - start.y;
    clampTranslate();
    updateTransform();
    justDragged = true;
  });

  window.addEventListener('mouseup', () => {
    isDragging = false;
    container.style.cursor = "grab";
  });

  updateTransform();
</script>
</body>
</html>
